[{"/Users/shermam/Projects/secure-router/.eslintrc.js":"1","/Users/shermam/Projects/secure-router/babel.config.js":"2","/Users/shermam/Projects/secure-router/src/index.test.ts":"3","/Users/shermam/Projects/secure-router/src/index.ts":"4","/Users/shermam/Projects/secure-router/src/types/router.d.ts":"5"},{"size":247,"mtime":1682595821046,"results":"6","hashOfConfig":"7"},{"size":237,"mtime":1682596200034,"results":"8","hashOfConfig":"7"},{"size":23966,"mtime":1685977168728,"results":"9","hashOfConfig":"7"},{"size":14024,"mtime":1685972003251,"results":"10","hashOfConfig":"7"},{"size":2962,"mtime":1685711001844,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1vdhuna",{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","suppressedMessages":"20","errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","suppressedMessages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24"},{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/shermam/Projects/secure-router/.eslintrc.js",[],[],"/Users/shermam/Projects/secure-router/babel.config.js",[],[],"/Users/shermam/Projects/secure-router/src/index.test.ts",["28","29"],[],"/Users/shermam/Projects/secure-router/src/index.ts",["30","31"],["32","33","34","35"],"import BaseRouter, {RouterMethod, ErrorHandleFunction, Path} from 'router';\nimport Promise from 'bluebird';\nimport _ from 'lodash';\nimport configureDebug from 'debug';\nimport http from 'http';\nimport pathToRegexp, {PathRegExp} from 'path-to-regexp';\nimport url from 'url';\nimport async from 'async';\nimport {Request, RequestHandler, Response} from 'express';\n\nconst debug = configureDebug('secure-router');\n\nconst AUTHORIZE = 'AUTHORIZE';\nconst AUTHENTICATE = 'AUTHENTICATE';\nconst DENY = 'DENY';\n\nexport type AccessStatus =\n  | typeof Router.AUTHORIZE\n  | typeof Router.AUTHENTICATE\n  | typeof Router.DENY;\n\nexport interface SecureRouterRequestHandler extends RequestHandler {\n  __mountpath?: string;\n}\n\nexport interface SecureRouterRequest extends Request {\n  matchedRoutes?: string[];\n  __route?: string;\n}\n\nconst parseError = (error: unknown): Error => {\n  if (error instanceof Error) return error;\n  return new Error(String(error));\n};\n\nclass Router extends BaseRouter {\n  pathDefinitions: Array<\n    NonNullable<\n      {\n        regexp: PathRegExp;\n        innerRouters: Router[];\n        bouncers: Array<\n          | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n          | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n        >;\n        methods: string[];\n      } & {\n        path: string;\n        innerRouters: Router[];\n        bouncers?: Array<\n          | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n          | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n        >;\n        methods?: string[];\n      }\n    >\n  >;\n  bouncers: Array<\n    | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n    | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n  >;\n  stack: SecureRouterRequestHandler[] = [];\n  /* eslint-disable @typescript-eslint/naming-convention */\n  static DENY: {value: string; middleware: (req: SecureRouterRequest, res: Response) => void};\n  static AUTHORIZE: {value: string};\n  static AUTHENTICATE: {value: string};\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  constructor(...args: undefined[]) {\n    super(...args);\n    this.bouncers = [];\n    this.pathDefinitions = [];\n  }\n\n  static denyWith({\n    params,\n    i,\n  }: {\n    params:\n      | {\n          statusCode?: number;\n          payload?: string | {error: true; ms: number};\n        }\n      | RequestHandler;\n    i?: number;\n  }): typeof Router.DENY {\n    if (_.isFunction(params)) {\n      debug('Creating denial with a provided middleware function');\n      const middleware = params;\n      return _.assign({}, Router.DENY, {middleware, i});\n    } else if (_.isObject(params)) {\n      debug('Creating denial with params', params);\n      const middleware = (_req: SecureRouterRequest, res: Response): void => {\n        debug('Responding to request with procedural denyWith middleware');\n        res.status(_.get(params, 'statusCode', 401));\n        res.send(params.payload);\n      };\n      return _.assign({}, Router.DENY, {middleware, i});\n    }\n    throw new Error(`Params must be an object or a function got: ${typeof params}`);\n  }\n\n  bounceRequests(): Router {\n    const router = this;\n    router.use(function (\n      req: SecureRouterRequest,\n      res: Response,\n      next: async.ErrorCallback<Error>,\n    ) {\n      const parsedUrl = url.parse(req.url);\n      router\n        .resolveCustomSecurity(req, res, parsedUrl.pathname as string)\n        .then(function (results: {value: string; middleware: any}) {\n          function match(result: {value: string}, expectedValue: string): boolean {\n            return _.isObject(result) && result.value === expectedValue;\n          }\n\n          function someResultsMatch(expectedValue: string): boolean {\n            return _.some(results, (result) => match(result, expectedValue));\n          }\n          function noResultsMatch(expectedValue: string): boolean {\n            return _.every(results, (result) => !match(result, expectedValue));\n          }\n\n          if (someResultsMatch(DENY)) {\n            const denyResults = _.filter(results, (result: {value: string}) => match(result, DENY));\n            debug('Got one or more DENY', {denyResults});\n            // TODO(@max) sort here???\n            async.eachSeries(\n              _.map(denyResults, function (result) {\n                return result.middleware;\n              }),\n              function (middleware, callback) {\n                try {\n                  middleware(req, res, callback);\n                } catch (err) {\n                  const error = parseError(err);\n                  debug('DENY middleware threw a synchronous error', error.stack);\n                  callback(error);\n                }\n              },\n              next,\n            );\n            return;\n          }\n\n          if (noResultsMatch(AUTHENTICATE)) {\n            debug('Got no AUTHENTICATE from any bouncer, sending 401', {results});\n            return res.sendStatus(401);\n          }\n\n          if (noResultsMatch(AUTHORIZE)) {\n            debug('Got no AUTHORIZE from any bouncer, sending 403', {results});\n            return res.sendStatus(403);\n          }\n\n          debug('Got one or more AUTHENTICATE and one or more AUTHORIZE', {results});\n          next();\n        });\n    });\n    return router;\n  }\n\n  secureSubpath(params: {\n    path: string;\n    bouncer?:\n      | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n      | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>);\n    bouncers?: Array<\n      | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n      | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n    >;\n  }): Router {\n    let {bouncers} = params;\n    if (_.isNil(bouncers)) bouncers = [];\n    if (_.isFunction(params.bouncer)) bouncers.push(params.bouncer);\n\n    const innerRouter = new Router();\n    this.pathDefinitions.push(\n      createPathDefinition({\n        path: params.path,\n        innerRouters: [innerRouter],\n        bouncers,\n      }),\n    );\n    this.use(params.path, innerRouter);\n    return innerRouter;\n  }\n\n  secureEndpoint(params: {\n    path: string;\n    method: string;\n    middleware: RequestHandler | RequestHandler[];\n    bouncer?:\n      | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n      | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>);\n    bouncers?: Array<\n      | ((\n          req: SecureRouterRequest,\n          res: Response,\n        ) => AccessStatus | Promise<AccessStatus> | undefined)\n      | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus> | undefined)\n    >;\n  }): Router {\n    let {bouncers} = params;\n    if (_.isNil(bouncers)) bouncers = [];\n    if (_.isFunction(params.bouncer)) bouncers.push(params.bouncer);\n\n    let {middleware} = params;\n    if (_.isFunction(middleware)) middleware = [middleware];\n\n    this.pathDefinitions.push(\n      createPathDefinition({\n        path: params.path,\n        bouncers,\n        methods: [params.method.toUpperCase()],\n      }),\n    );\n\n    /* actually mount the route */\n    this[params.method.toLowerCase() as RouterMethod](params.path, ...middleware);\n    return this;\n  }\n\n  use = (path: Path | RequestHandler | ErrorHandleFunction, ...innerRouters: Router[]): void => {\n    function isSecureRouter(router: Router): boolean {\n      return _.isFunction(router.resolveCustomSecurity);\n    }\n\n    const pathIsString = _.isString(path);\n    if (pathIsString) {\n      let {pathDefinition} = this.getPathDefinitionMatching(path);\n      if (_.isNil(pathDefinition)) {\n        pathDefinition = createPathDefinition({path});\n        this.pathDefinitions.push(pathDefinition);\n      }\n      innerRouters = innerRouters.filter(isSecureRouter);\n      pathDefinition.innerRouters.push(...innerRouters);\n    } else {\n      innerRouters = [path, ...innerRouters].filter(isSecureRouter);\n      for (const innerRouter of innerRouters) {\n        this.bouncers.push(...innerRouter.bouncers);\n        this.pathDefinitions.push(...innerRouter.pathDefinitions);\n      }\n    }\n\n    let offset = this.stack.length;\n    BaseRouter.prototype.use.apply(this, Router.arguments);\n\n    // Inspired by https://github.com/expressjs/express/issues/2879#issuecomment-180088895\n    /* so that in our monkey patch of process_params, we can know about the\n     * path of this part of the route */\n    if (pathIsString) {\n      for (; offset < this.stack.length; offset++) {\n        const layer = this.stack[offset];\n        layer.__mountpath = path;\n      }\n    }\n  };\n\n  // Inspired by https://github.com/expressjs/express/issues/2879#issuecomment-180088895\n\n  /* eslint-disable @typescript-eslint/naming-convention */\n  process_params = (\n    layer: {keys: Array<{name: string | number}>},\n    _called: unknown,\n    req: SecureRouterRequest,\n  ): void => {\n    const path: string = _.get(\n      req,\n      'route.path',\n      _.get(req, 'route.regexp.source', _.get(layer, '__mountpath', '')),\n    );\n\n    if (req.matchedRoutes == null) req.matchedRoutes = [];\n    req.__route = (req.__route || '') + path;\n\n    const normalizedPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n    if (!_.isEmpty(normalizedPath) && normalizedPath !== _.last(req.matchedRoutes)) {\n      req.matchedRoutes.push(normalizedPath);\n    }\n\n    BaseRouter.prototype.process_params.apply(this, Router.arguments);\n  };\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  bouncer({\n    bouncer,\n  }: {\n    bouncer:\n      | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n      | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>);\n  }): void {\n    this.bouncers.push(bouncer);\n  }\n\n  /* returns a promise. runs all of the appropriate bouncers configured for this route.  */\n  resolveCustomSecurity(req: SecureRouterRequest, res: Response, urlSegment: string): Promise<any> {\n    return Promise.try(async () => {\n      const bouncers: Array<\n        | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n        | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n      > = [...this.bouncers];\n      const innerRouters: Router[] = [];\n\n      const {pathDefinition, matchedUrlSegment} = this.getPathDefinitionMatching(\n        urlSegment,\n        req.method,\n      );\n      debug('Found matching path definitions', {pathDefinition, matchedUrlSegment});\n      if (_.isObject(pathDefinition)) {\n        urlSegment = urlSegment.substring(0, matchedUrlSegment.length);\n        bouncers.push(...pathDefinition.bouncers);\n        innerRouters.push(...pathDefinition.innerRouters);\n      }\n\n      const [bouncerResults, innerRouterResults] = await Promise.all([\n        Promise.map(bouncers, (bouncer) => Promise.resolve(bouncer(req, res))),\n        Promise.map(innerRouters, (innerRouter) =>\n          innerRouter.resolveCustomSecurity(req, res, urlSegment),\n        ),\n      ]);\n      return bouncerResults.concat(_.flatten(innerRouterResults));\n    });\n  }\n\n  getPathDefinitionMatching(\n    urlSegment: string,\n    method?: string,\n  ): {\n    pathDefinition: NonNullable<\n      {\n        regexp: PathRegExp;\n        innerRouters: Router[];\n        bouncers: Array<\n          | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n          | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n        >;\n        methods: string[];\n      } & {\n        path: string;\n        innerRouters: Router[];\n        bouncers?: Array<\n          | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n          | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n        >;\n        methods?: string[];\n      }\n    > | null;\n    matchedUrlSegment: string;\n  } {\n    let matches: RegExpExecArray | null, hasMethod: boolean;\n    /* start with most specific path definition */\n    this.pathDefinitions.sort(\n      (a, b) => _.compact(b.path.split('/')).length - _.compact(a.path.split('/')).length,\n    );\n    for (const pathDefinition of this.pathDefinitions) {\n      matches = pathDefinition.regexp.exec(urlSegment);\n      hasMethod = _.isNil(method) || _.includes(pathDefinition.methods, method);\n      if (_.isArray(matches) && matches.length > 0 && hasMethod) {\n        return {pathDefinition, matchedUrlSegment: matches[0]};\n      }\n    }\n    return {pathDefinition: null, matchedUrlSegment: ''};\n  }\n}\n\nRouter.AUTHORIZE = {value: AUTHORIZE};\nRouter.AUTHENTICATE = {value: AUTHENTICATE};\nRouter.DENY = {\n  value: DENY,\n  middleware(_req, res) {\n    debug('Default DENY middleware responding with 401');\n    res.sendStatus(401);\n  },\n};\n\nfunction createPathDefinition(definition: {\n  path: string;\n  innerRouters?: Router[];\n  bouncers?: Array<\n    | ((\n        req: SecureRouterRequest,\n        res: Response,\n      ) => AccessStatus | Promise<AccessStatus> | undefined)\n    | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus> | undefined)\n  >;\n  methods?: string[];\n}): NonNullable<\n  {\n    regexp: PathRegExp;\n    innerRouters: Router[];\n    bouncers: Array<\n      | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n      | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n    >;\n    methods: string[];\n  } & {\n    path: string;\n    innerRouters?: Router[];\n    bouncers?: Array<\n      | ((req: SecureRouterRequest, res: Response) => AccessStatus | Promise<AccessStatus>)\n      | ((req: SecureRouterRequest) => AccessStatus | Promise<AccessStatus>)\n    >;\n    methods?: string[];\n  }\n> {\n  return _.defaults({}, definition, {\n    regexp: pathToRegexp(definition.path, {end: false, sensitive: true, strict: false}),\n    innerRouters: [],\n    bouncers: [],\n    methods: http.METHODS,\n  });\n}\n\nexport default Router;\n","/Users/shermam/Projects/secure-router/src/types/router.d.ts",[],["36","37","38"],{"ruleId":"39","severity":2,"message":"40","line":620,"column":79,"nodeType":"41","messageId":"42","endLine":620,"endColumn":98},{"ruleId":"39","severity":2,"message":"40","line":628,"column":98,"nodeType":"41","messageId":"42","endLine":628,"endColumn":120},{"ruleId":"43","severity":1,"message":"44","line":113,"column":62,"nodeType":"45","messageId":"46","endLine":113,"endColumn":65,"suggestions":"47"},{"ruleId":"43","severity":1,"message":"44","line":298,"column":95,"nodeType":"45","messageId":"46","endLine":298,"endColumn":98,"suggestions":"48"},{"ruleId":"49","severity":2,"message":"50","line":64,"column":10,"nodeType":"51","messageId":"52","endLine":64,"endColumn":14,"suppressions":"53"},{"ruleId":"49","severity":2,"message":"54","line":65,"column":10,"nodeType":"51","messageId":"52","endLine":65,"endColumn":19,"suppressions":"55"},{"ruleId":"49","severity":2,"message":"56","line":66,"column":10,"nodeType":"51","messageId":"52","endLine":66,"endColumn":22,"suppressions":"57"},{"ruleId":"49","severity":2,"message":"58","line":264,"column":3,"nodeType":"51","messageId":"52","endLine":264,"endColumn":17,"suppressions":"59"},{"ruleId":"49","severity":2,"message":"60","line":59,"column":7,"nodeType":"51","messageId":"52","endLine":59,"endColumn":21,"suppressions":"61"},{"ruleId":"49","severity":2,"message":"62","line":84,"column":7,"nodeType":"51","messageId":"52","endLine":84,"endColumn":12,"suppressions":"63"},{"ruleId":"49","severity":2,"message":"64","line":91,"column":9,"nodeType":"51","messageId":"52","endLine":91,"endColumn":27,"suppressions":"65"},"@typescript-eslint/restrict-template-expressions","Invalid type \"any\" of template literal expression.","MemberExpression","invalidType","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["66","67"],["68","69"],"@typescript-eslint/naming-convention","Class Property name `DENY` must match one of the following formats: camelCase","Identifier","doesNotMatchFormat",["70"],"Class Property name `AUTHORIZE` must match one of the following formats: camelCase",["71"],"Class Property name `AUTHENTICATE` must match one of the following formats: camelCase",["72"],"Class Method name `process_params` must match one of the following formats: camelCase",["73"],"Type Method name `process_params` must match one of the following formats: camelCase",["74"],"Type Property name `Route` must match one of the following formats: camelCase",["75"],"Variable name `Router` must match one of the following formats: camelCase, UPPER_CASE",["76"],{"messageId":"77","fix":"78","desc":"79"},{"messageId":"80","fix":"81","desc":"82"},{"messageId":"77","fix":"83","desc":"79"},{"messageId":"80","fix":"84","desc":"82"},{"kind":"85","justification":"86"},{"kind":"85","justification":"86"},{"kind":"85","justification":"86"},{"kind":"85","justification":"86"},{"kind":"85","justification":"86"},{"kind":"85","justification":"86"},{"kind":"85","justification":"86"},"suggestUnknown",{"range":"87","text":"88"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"87","text":"89"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"90","text":"88"},{"range":"90","text":"89"},"directive","",[3583,3586],"unknown","never",[10070,10073]]